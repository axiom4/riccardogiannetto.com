/**
 * Riccardo Giannetto  API
 *
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional } from '@angular/core';
import {
  HttpClient,
  HttpResponse,
  HttpEvent,
  HttpContext,
} from '@angular/common/http';
import { Observable } from 'rxjs';
import { OpenApiHttpParams, QueryParamStyle } from '../query.params';

// @ts-ignore
import { Gallery } from '../model/gallery';
// @ts-ignore
import { ImageGallery } from '../model/imageGallery';
// @ts-ignore
import { PaginatedGalleryList } from '../model/paginatedGalleryList';
// @ts-ignore
import { PaginatedImageGalleryList } from '../model/paginatedImageGalleryList';

// @ts-ignore
import { BASE_PATH } from '../variables';
import { Configuration } from '../configuration';
import { BaseService } from '../api.base.service';
import {
  PortfolioServiceInterface,
  PortfolioGalleriesListRequestParams,
  PortfolioGalleriesRetrieveRequestParams,
  PortfolioImagesListRequestParams,
  PortfolioImagesRetrieveRequestParams,
  PortfolioImagesWidthRetrieveRequestParams,
} from './portfolio.serviceInterface';

@Injectable({
  providedIn: 'root',
})
export class PortfolioService
  extends BaseService
  implements PortfolioServiceInterface
{
  constructor(
    protected httpClient: HttpClient,
    @Optional() @Inject(BASE_PATH) basePath: string | string[],
    @Optional() configuration?: Configuration,
  ) {
    super(basePath, configuration);
  }

  /**
   * A ViewSet for viewing Gallery instances.  This ViewSet provides &#x60;list&#x60; and &#x60;retrieve&#x60; actions for Gallery objects, supporting filtering, searching, and ordering.  Attributes:     queryset (QuerySet): The base queryset for retrieving galleries,         optimized with &#x60;select_related&#x60; and &#x60;prefetch_related&#x60;.     serializer_class (Serializer): The serializer class used for         validating and deserializing input, and for serializing output.     permission_classes (list): The list of permission classes that         determine access rights (Authenticated or ReadOnly).     filter_backends (list): The backends used for filtering the queryset.     http_method_names (list): The allowed HTTP method names (\&#39;get\&#39; only).     pagination_class (Pagination): The pagination class used for         paginating results.     ordering_fields (str or list): The fields allowed for ordering.     filterset_fields (list): The fields used for exact match filtering.     search_fields (list): The fields used for full-text search.
   * @endpoint get /portfolio/galleries
   * @param requestParameters
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param options additional options
   */
  public portfolioGalleriesList(
    requestParameters?: PortfolioGalleriesListRequestParams,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<PaginatedGalleryList>;
  public portfolioGalleriesList(
    requestParameters?: PortfolioGalleriesListRequestParams,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpResponse<PaginatedGalleryList>>;
  public portfolioGalleriesList(
    requestParameters?: PortfolioGalleriesListRequestParams,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpEvent<PaginatedGalleryList>>;
  public portfolioGalleriesList(
    requestParameters?: PortfolioGalleriesListRequestParams,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<any> {
    const ordering = requestParameters?.ordering;
    const page = requestParameters?.page;
    const pageSize = requestParameters?.pageSize;
    const search = requestParameters?.search;
    const title = requestParameters?.title;

    let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      'ordering',
      <any>ordering,
      QueryParamStyle.Form,
      true,
    );

    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      'page',
      <any>page,
      QueryParamStyle.Form,
      true,
    );

    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      'page_size',
      <any>pageSize,
      QueryParamStyle.Form,
      true,
    );

    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      'search',
      <any>search,
      QueryParamStyle.Form,
      true,
    );

    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      'title',
      <any>title,
      QueryParamStyle.Form,
      true,
    );

    let localVarHeaders = this.defaultHeaders;

    // authentication (basicAuth) required
    localVarHeaders = this.configuration.addCredentialToHeaders(
      'basicAuth',
      'Authorization',
      localVarHeaders,
      'Basic ',
    );

    // authentication (cookieAuth) required

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json']);
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected,
      );
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext();

    const localVarTransferCache: boolean = options?.transferCache ?? true;

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/portfolio/galleries`;
    const { basePath, withCredentials } = this.configuration;
    return this.httpClient.request<PaginatedGalleryList>(
      'get',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        params: localVarQueryParameters.toHttpParams(),
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      },
    );
  }

  /**
   * A ViewSet for viewing Gallery instances.  This ViewSet provides &#x60;list&#x60; and &#x60;retrieve&#x60; actions for Gallery objects, supporting filtering, searching, and ordering.  Attributes:     queryset (QuerySet): The base queryset for retrieving galleries,         optimized with &#x60;select_related&#x60; and &#x60;prefetch_related&#x60;.     serializer_class (Serializer): The serializer class used for         validating and deserializing input, and for serializing output.     permission_classes (list): The list of permission classes that         determine access rights (Authenticated or ReadOnly).     filter_backends (list): The backends used for filtering the queryset.     http_method_names (list): The allowed HTTP method names (\&#39;get\&#39; only).     pagination_class (Pagination): The pagination class used for         paginating results.     ordering_fields (str or list): The fields allowed for ordering.     filterset_fields (list): The fields used for exact match filtering.     search_fields (list): The fields used for full-text search.
   * @endpoint get /portfolio/galleries/{id}
   * @param requestParameters
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param options additional options
   */
  public portfolioGalleriesRetrieve(
    requestParameters: PortfolioGalleriesRetrieveRequestParams,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<Gallery>;
  public portfolioGalleriesRetrieve(
    requestParameters: PortfolioGalleriesRetrieveRequestParams,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpResponse<Gallery>>;
  public portfolioGalleriesRetrieve(
    requestParameters: PortfolioGalleriesRetrieveRequestParams,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpEvent<Gallery>>;
  public portfolioGalleriesRetrieve(
    requestParameters: PortfolioGalleriesRetrieveRequestParams,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<any> {
    const id = requestParameters?.id;
    if (id === null || id === undefined) {
      throw new Error(
        'Required parameter id was null or undefined when calling portfolioGalleriesRetrieve.',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    // authentication (basicAuth) required
    localVarHeaders = this.configuration.addCredentialToHeaders(
      'basicAuth',
      'Authorization',
      localVarHeaders,
      'Basic ',
    );

    // authentication (cookieAuth) required

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json']);
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected,
      );
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext();

    const localVarTransferCache: boolean = options?.transferCache ?? true;

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/portfolio/galleries/${this.configuration.encodeParam({ name: 'id', value: id, in: 'path', style: 'simple', explode: false, dataType: 'number', dataFormat: undefined })}`;
    const { basePath, withCredentials } = this.configuration;
    return this.httpClient.request<Gallery>(
      'get',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      },
    );
  }

  /**
   * Docstring for ImageGalleryViewSet  :var Args: Description :var request: Description :vartype request: The :var Returns: Description :var Response: Description :vartype Response: The A viewset for viewing image galleries.  This viewset provides &#x60;list&#x60; and &#x60;retrieve&#x60; actions for ImageGallery objects. It supports filtering by gallery, searching by title, and ordering by various fields. It also includes a custom action to retrieve images in specific widths.  Attributes:     queryset(QuerySet): The base queryset for the viewset, optimizing database access         by using &#x60;select_related&#x60; for author and gallery, and &#x60;prefetch_related&#x60; for tags.     serializer_class(Serializer): The serializer class used for validating and         deserializing input, and for serializing output.     permission_classes(list): The list of permission classes that determine access rights.         Defaults to allowing authenticated users to edit, and read-only access for others.     filter_backends(list): The backends used for filtering,         searching, and ordering the queryset.     http_method_names(list): The allowed HTTP methods(currently restricted to \&#39;get\&#39;).     pagination_class(Pagination): The pagination class used to paginate the results.     renderer_classes(list): The renderers used to render the response.     ordering_fields(list): The fields that can be used for ordering the results.     filterset_fields(list): The fields that can be used for precise filtering.     search_fields(list): The fields that can be searched using the search filter.
   * @endpoint get /portfolio/images
   * @param requestParameters
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param options additional options
   */
  public portfolioImagesList(
    requestParameters?: PortfolioImagesListRequestParams,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<PaginatedImageGalleryList>;
  public portfolioImagesList(
    requestParameters?: PortfolioImagesListRequestParams,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpResponse<PaginatedImageGalleryList>>;
  public portfolioImagesList(
    requestParameters?: PortfolioImagesListRequestParams,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpEvent<PaginatedImageGalleryList>>;
  public portfolioImagesList(
    requestParameters?: PortfolioImagesListRequestParams,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<any> {
    const gallery = requestParameters?.gallery;
    const ordering = requestParameters?.ordering;
    const page = requestParameters?.page;
    const pageSize = requestParameters?.pageSize;
    const search = requestParameters?.search;

    let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      'gallery',
      <any>gallery,
      QueryParamStyle.Form,
      true,
    );

    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      'ordering',
      <any>ordering,
      QueryParamStyle.Form,
      true,
    );

    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      'page',
      <any>page,
      QueryParamStyle.Form,
      true,
    );

    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      'page_size',
      <any>pageSize,
      QueryParamStyle.Form,
      true,
    );

    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      'search',
      <any>search,
      QueryParamStyle.Form,
      true,
    );

    let localVarHeaders = this.defaultHeaders;

    // authentication (basicAuth) required
    localVarHeaders = this.configuration.addCredentialToHeaders(
      'basicAuth',
      'Authorization',
      localVarHeaders,
      'Basic ',
    );

    // authentication (cookieAuth) required

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json']);
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected,
      );
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext();

    const localVarTransferCache: boolean = options?.transferCache ?? true;

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/portfolio/images`;
    const { basePath, withCredentials } = this.configuration;
    return this.httpClient.request<PaginatedImageGalleryList>(
      'get',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        params: localVarQueryParameters.toHttpParams(),
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      },
    );
  }

  /**
   * Docstring for ImageGalleryViewSet  :var Args: Description :var request: Description :vartype request: The :var Returns: Description :var Response: Description :vartype Response: The A viewset for viewing image galleries.  This viewset provides &#x60;list&#x60; and &#x60;retrieve&#x60; actions for ImageGallery objects. It supports filtering by gallery, searching by title, and ordering by various fields. It also includes a custom action to retrieve images in specific widths.  Attributes:     queryset(QuerySet): The base queryset for the viewset, optimizing database access         by using &#x60;select_related&#x60; for author and gallery, and &#x60;prefetch_related&#x60; for tags.     serializer_class(Serializer): The serializer class used for validating and         deserializing input, and for serializing output.     permission_classes(list): The list of permission classes that determine access rights.         Defaults to allowing authenticated users to edit, and read-only access for others.     filter_backends(list): The backends used for filtering,         searching, and ordering the queryset.     http_method_names(list): The allowed HTTP methods(currently restricted to \&#39;get\&#39;).     pagination_class(Pagination): The pagination class used to paginate the results.     renderer_classes(list): The renderers used to render the response.     ordering_fields(list): The fields that can be used for ordering the results.     filterset_fields(list): The fields that can be used for precise filtering.     search_fields(list): The fields that can be searched using the search filter.
   * @endpoint get /portfolio/images/{id}
   * @param requestParameters
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param options additional options
   */
  public portfolioImagesRetrieve(
    requestParameters: PortfolioImagesRetrieveRequestParams,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<ImageGallery>;
  public portfolioImagesRetrieve(
    requestParameters: PortfolioImagesRetrieveRequestParams,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpResponse<ImageGallery>>;
  public portfolioImagesRetrieve(
    requestParameters: PortfolioImagesRetrieveRequestParams,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpEvent<ImageGallery>>;
  public portfolioImagesRetrieve(
    requestParameters: PortfolioImagesRetrieveRequestParams,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<any> {
    const id = requestParameters?.id;
    if (id === null || id === undefined) {
      throw new Error(
        'Required parameter id was null or undefined when calling portfolioImagesRetrieve.',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    // authentication (basicAuth) required
    localVarHeaders = this.configuration.addCredentialToHeaders(
      'basicAuth',
      'Authorization',
      localVarHeaders,
      'Basic ',
    );

    // authentication (cookieAuth) required

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json']);
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected,
      );
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext();

    const localVarTransferCache: boolean = options?.transferCache ?? true;

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/portfolio/images/${this.configuration.encodeParam({ name: 'id', value: id, in: 'path', style: 'simple', explode: false, dataType: 'number', dataFormat: undefined })}`;
    const { basePath, withCredentials } = this.configuration;
    return this.httpClient.request<ImageGallery>(
      'get',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      },
    );
  }

  /**
   * Retrieve and return image gallery data in JPEG format.  Args:     request: The HTTP request object.     *args: Variable length argument list.     **kwargs: Arbitrary keyword arguments.  Returns:     Response: The serialized image gallery data.
   * @endpoint get /portfolio/images/{id}/width/{width}
   * @param requestParameters
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param options additional options
   */
  public portfolioImagesWidthRetrieve(
    requestParameters: PortfolioImagesWidthRetrieveRequestParams,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'image/webp';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<ImageGallery>;
  public portfolioImagesWidthRetrieve(
    requestParameters: PortfolioImagesWidthRetrieveRequestParams,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'image/webp';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpResponse<ImageGallery>>;
  public portfolioImagesWidthRetrieve(
    requestParameters: PortfolioImagesWidthRetrieveRequestParams,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'image/webp';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpEvent<ImageGallery>>;
  public portfolioImagesWidthRetrieve(
    requestParameters: PortfolioImagesWidthRetrieveRequestParams,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'image/webp';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<any> {
    const id = requestParameters?.id;
    if (id === null || id === undefined) {
      throw new Error(
        'Required parameter id was null or undefined when calling portfolioImagesWidthRetrieve.',
      );
    }
    const width = requestParameters?.width;
    if (width === null || width === undefined) {
      throw new Error(
        'Required parameter width was null or undefined when calling portfolioImagesWidthRetrieve.',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    // authentication (basicAuth) required
    localVarHeaders = this.configuration.addCredentialToHeaders(
      'basicAuth',
      'Authorization',
      localVarHeaders,
      'Basic ',
    );

    // authentication (cookieAuth) required

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['image/webp']);
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected,
      );
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext();

    const localVarTransferCache: boolean = options?.transferCache ?? true;

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/portfolio/images/${this.configuration.encodeParam({ name: 'id', value: id, in: 'path', style: 'simple', explode: false, dataType: 'number', dataFormat: undefined })}/width/${this.configuration.encodeParam({ name: 'width', value: width, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}`;
    const { basePath, withCredentials } = this.configuration;
    return this.httpClient.request<ImageGallery>(
      'get',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      },
    );
  }
}
